title: Работа с транзакциями и DBAPI

## Работа с транзакциями и DBAPI

С Engine готовым к использованию, мы можем приступить к изучению основных операций с Engine и его основных интерактивных
точек, Connection и Result. Кроме того, мы введем фасад ORM для этих объектов, известный как Session.

???+ info "Примечание для читателей ORM"

    При использовании ORM Engine управляется другим объектом, называемым Session. Session в современном SQLAlchemy
    подчеркивает транзакционную и SQL-экспертную модель, которая в основном идентична обсуждаемой ниже Connection, поэтому,
    хотя этот подраздел сосредоточен на Core, все эти концепции существенно важны для ORM-пользователей и рекомендуются для
    всех изучающих ORM. Образец использования Connection будет сопоставлен с Session в конце этого раздела.

Поскольку мы еще не вводили Expression Language SQLAlchemy, который является основной особенностью SQLAlchemy, мы будем
использовать одну простую конструкцию внутри этого пакета, называемую text(), которая позволяет нам записывать
SQL-запросы в виде текстового SQL. Не стоит беспокоиться о том, что текстовый SQL в повседневном использовании
SQLAlchemy является скорее исключением, а не правилом для большинства задач, хотя он всегда остается полностью
доступным.

---

### Получение соединения {#getting-a-connection}

Единственная цель объекта Engine с точки зрения пользователя - предоставить единицу подключения к базе данных,
называемую Connection. При работе с Core напрямую, объект Connection является единственным способом взаимодействия с
базой данных. Так как Connection представляет открытый ресурс для доступа к базе данных, мы всегда должны ограничивать
область его использования конкретным контекстом, а лучший способ сделать это - использовать форму менеджера контекста
Python, также известную как оператор with. Ниже мы иллюстрируем "Hello World", используя текстовый SQL-запрос. Текстовый
SQL генерируется с помощью конструкции text(), о которой будет более подробно рассказано позже:

``` python

from sqlalchemy import text

with engine.connect() as conn:
    result = conn.execute(text("select 'hello world'"))
    print(result.all())

# сгенерированный SQL
BEGIN(implicit)
select
'hello world'
[...]()

# распечатанный result полученный в ходе execute (Python)
[('hello world',)]

# SQL откат транзакции
ROLLBACK

```

В приведенном выше примере, менеджер контекста предоставил подключение к базе данных и также ограничил операцию в рамках
транзакции. По умолчанию поведение Python DBAPI включает то, что транзакция всегда находится в процессе; когда область
действия соединения освобождается, выполняется операция ROLLBACK для завершения транзакции. Транзакция не фиксируется
автоматически; когда мы хотим зафиксировать данные, мы обычно должны вызывать Connection.commit(), как мы увидим в
следующем разделе.

!!! tip "Совет"

    "Автовыполнение" режима доступен для специальных случаев. Раздел "Установка уровней изоляции транзакции", включая "DBAPI
    Autocommit", описывает это.

Результат нашего SELECT также был возвращен в объекте Result, который будет обсуждаться позже, однако на данный момент
стоит отметить, что лучше всего убедиться, что этот объект используется внутри блока "connect" и не передается за его
пределы.

---

### Фиксируем изменения {#committing-changes}

Мы только что узнали, что соединение с БД через DBAPI не имеет автофиксации. Что, если мы хотим зафиксировать
некоторые данные? Мы можем изменить наш предыдущий пример, создав таблицу и добавив некоторые данные. Транзакция затем
фиксируется с помощью метода Connection.commit(), вызванного внутри блока, где мы получили объект Connection:

``` python
# "commit as you go"

>>> with engine.connect() as conn:
...     conn.execute(text("CREATE TABLE some_table (x int, y int)"))
...     conn.execute(
...     text("INSERT INTO some_table (x, y) VALUES (:x, :y)"),
...             [{"x": 1, "y": 1}, {"x": 2, "y": 4}],
...         )
...     conn.commit()

# выполненный SQL
BEGIN (implicit)
CREATE TABLE some_table (x int, y int)
[...] ()
<sqlalchemy.engine.cursor.CursorResult object at 0x...>
INSERT INTO some_table (x, y) VALUES (?, ?)
[...] [(1, 1), (2, 4)]
<sqlalchemy.engine.cursor.CursorResult object at 0x...>
COMMIT
```

В приведенном выше примере мы выполняем два SQL-запроса, которые, как правило, являются транзакционными: запрос на "
CREATE TABLE" [[1](#mark-1)] и запрос на "INSERT", параметризованный (синтаксис параметризации выше будет рассмотрен
ниже в
разделе "Отправка нескольких параметров"). Так как мы хотим, чтобы наша работа была зафиксирована в рамках блока, мы
вызываем метод Connection.commit(), который фиксирует транзакцию. После того как мы вызвали этот метод внутри блока, мы
можем продолжить выполнять SQL-запросы и, если хотим, можем вызвать Connection.commit() еще раз для последующих
запросов. SQLAlchemy называет этот стиль "фиксирование изменений по мере выполнения".

Есть еще один способ фиксации данных, который заключается в том, что мы можем заранее объявить наш блок "connect" как
блок транзакции. Для этого режима работы мы используем метод Engine.begin() для получения соединения вместо метода
Engine.connect(). Этот метод будет управлять областью действия Connection и также заключит все внутри транзакции с
COMMIT в конце, в случае успешного выполнения блока, или ROLLBACK в случае возникновения исключения. Этот стиль может
быть назван "begin once":

``` python

# "begin once"
>>> with engine.begin() as conn:
...     conn.execute(
...         text("INSERT INTO some_table (x, y) VALUES (:x, :y)"),
...         [{"x": 6, "y": 8}, {"x": 9, "y": 10}],
...     )

# SQL
BEGIN (implicit)
INSERT INTO some_table (x, y) VALUES (?, ?)
[...] [(6, 8), (9, 10)]
<sqlalchemy.engine.cursor.CursorResult object at 0x...>
COMMIT

```

Стиль "begin once" часто предпочитается, так как он более лаконичен и позволяет заранее указать намерение всего
блока. Однако в этом руководстве мы обычно будем использовать стиль "фиксировать по мере выполнения", так как он более
гибкий для демонстрационных целей.

!!! info "Что такое "BEGIN (implicit)"?"

    Вы могли заметить строку журнала "BEGIN (implicit)" в начале блока транзакции. "implicit" здесь означает, что SQLAlchemy
    на самом деле не отправляет никакую команду в базу данных; он просто считает это началом неявной транзакции DBAPI. Вы
    можете зарегистрировать события для перехвата этого события, например. 

#### примечание [1] {#mark-1}

DDL относится к подмножеству SQL, которое указывает базе данных создавать, изменять или удалять конструкции на уровне
схемы, такие как таблицы. Рекомендуется помещать DDL, такой, как "CREATE TABLE", в блок транзакции, который
заканчивается
COMMIT, так как многие базы данных используют транзакционный DDL, при котором изменения схемы не происходят до тех пор,
пока транзакция не будет зафиксирована. Однако, как мы увидим позже, обычно мы позволяем SQLAlchemy запускать
последовательности DDL для нас как часть операции более высокого уровня, где нам обычно не нужно беспокоиться о COMMIT.

--- 

### Основы выполнения утверждений(statements) {#basics-of-statement-execution}

Мы рассмотрели несколько примеров выполнения операторов SQL в базе данных, используя метод Connection.execute()
совместно с объектом text() и возвращающимся объектом Result. В этом разделе мы более подробно проиллюстрируем механику
и взаимодействие этих компонентов.

???+ info "Об разделе"

    Большая часть содержимого этого раздела одинаково хорошо применима и к современному использованию ORM, при использовании
    метода Session.execute(), который работает очень похоже на Connection.execute(), включая то, что строки результатов ORM
    доставляются с использованием того же интерфейса Result, что и в Core.

#### Извлечение строк {#fetching-rows}

Сначала мы более детально рассмотрим объект Result, используя строки, которые мы ранее вставляли, выполняя текстовый
оператор SELECT на созданной нами таблице:

``` python
>>> with engine.connect() as conn:
...     result = conn.execute(text("SELECT x, y FROM some_table"))
...     for row in result:
...         print(f"x: {row.x} y: {row.y}")

# SQL
BEGIN (implicit)
SELECT x, y FROM some_table
[...] ()

# Python output
x: 1 y: 1
x: 2 y: 4
x: 6 y: 8
x: 9 y: 10

ROLLBACK
```

В приведенном выше примере строка "SELECT" выбрала все строки из нашей таблицы. Возвращаемый объект называется Result и
представляет итерируемый объект строк результатов.

У Result есть много методов для извлечения и преобразования строк, таких как метод Result.all (), показанный ранее,
который возвращает список всех объектов Row. Он также реализует интерфейс Python итератора, чтобы мы могли прямо
перебирать коллекцию объектов Row.

Сами объекты Row реализованы как именованные кортежи Python. Ниже мы иллюстрируем различные способы доступа к
строкам.

- **Распаковка кортежей** - Это наиболее Python-идиоматичный стиль, который заключается в присваивании переменных каждой
  позиции строки при ее получении:

    ``` python
    result = conn.execute(text("select x, y from some_table"))
    
    for x, y in result:
    ...
    ```

- **По индексу** - Кортежи являются последовательностями Python, так что доступ по обычному целочисленному индексу
  также доступен:

    ``` python
    result = conn.execute(text("select x, y from some_table"))
    
    for row in result:
        x = row[0]
    ```

- **По имени атрибута** - Поскольку это именованные кортежи Python, кортежи имеют динамические имена атрибутов,
  соответствующие
  именам каждого столбца. Эти имена обычно соответствуют именам, которые оператор SQL присваивает столбцам в каждой
  строке. Хотя они обычно достаточно предсказуемы и могут также управляться метками, в менее определенных случаях они
  могут подвергаться воздействию специфичных для базы данных поведений:

    ``` python
    result = conn.execute(text("select x, y from some_table"))
    
    for row in result:
        y = row.y
    
        # illustrate use with Python f-strings
        print(f"Row: {row.x} {y}")
    ```

- **По словарю** - Для получения строк в виде объектов отображения Python, которые являются существенно только для
  чтения версией
  интерфейса Python для общего объекта dict, Result может быть преобразован в объект MappingResult с помощью
  модификатора
  Result.mappings(); это объект результата, который возвращает объекты RowMapping, похожие на словари, вместо
  объектов
  Row:

      ``` python
      result = conn.execute(text("select x, y from some_table"))
        
      for dict_row in result.mappings():
          x = dict_row["x"]
          y = dict_row["y"]
            
      ```

#### Передача параметров {#sending-parameters}

SQL-запросы обычно сопровождаются данными, которые необходимо передать вместе с запросом, как мы видели в примере с
INSERT ранее. Метод Connection.execute() также принимает параметры, которые называются связанными параметрами. Примером
может быть запрос SELECT, который ограничивает количество строк, удовлетворяющих определенным условиям, таким как
строки, где значение поля "y" больше определенного значения, которое передается в функцию.

Чтобы этого достичь и при этом запрос SQL мог оставаться неизменным, а драйвер мог правильно обработать значение, мы
добавляем в WHERE-критерий запроса параметр с именем "y"; для этого мы используем конструкцию text(), в которую
добавляем "y" в формате с двоеточием " :y". Фактическое значение для ":y" передается вторым аргументом в
Connection.execute() в виде словаря:

``` python
>>> with engine.connect() as conn:
...     result = conn.execute(text("SELECT x, y FROM some_table WHERE y > :y"), {"y": 2})
...     for row in result:
...         print(f"x: {row.x}  y: {row.y}")

BEGIN (implicit)
SELECT x, y FROM some_table WHERE y > ?
[...] (2,)

x: 2  y: 4
x: 6  y: 8
x: 9  y: 10

ROLLBACK

```

В логах SQL-запросов мы можем видеть, что связанный параметр :y был преобразован в вопросительный знак при отправке в
базу данных SQLite. Это происходит потому, что драйвер базы данных SQLite использует формат «qmark parameter style»,
который является одним из шести различных форматов, разрешенных спецификацией DBAPI. SQLAlchemy абстрагирует эти форматы
в один - «именованный» формат с использованием двоеточия.

!!! tip "Всегда используйте связанные параметры"

    Как упоминалось в начале этого раздела, текстовый SQL не является обычным способом работы с SQLAlchemy. Однако, при
    использовании текстового SQL, литеральное значение Python, даже не-строковое, такое, как целые числа или даты, никогда
    не
    должно быть преобразовано в строку SQL напрямую; всегда следует использовать параметр. Это известно своей способностью
    предотвращать атаки SQL-инъекций, когда данные являются ненадежными. Однако это также позволяет диалектам SQLAlchemy
    и/или DBAPI правильно обрабатывать входные данные для соответствующей базы данных. Вне случаев использования обычного
    текстового SQL, Core Expression API SQLAlchemy обычно обеспечивает передачу литеральных значений Python как связанных
    параметров, где это необходимо.

#### Отправка нескольких параметров {#sending-multiple-parameters}

В примере в разделе Committing Changes мы выполнили оператор INSERT, где, казалось бы, мы смогли вставить сразу
несколько строк в базу данных. Для операторов DML, таких как "INSERT", "UPDATE" и "DELETE", мы можем отправить несколько
наборов параметров в метод Connection.execute(), передав список словарей вместо одного словаря, что указывает на то, что
один SQL-запрос должен быть выполнен несколько раз, один раз для каждого набора параметров. Этот стиль выполнения
известен как executemany:

``` python
>>> with engine.connect() as conn:
...     conn.execute(
...         text("INSERT INTO some_table (x, y) VALUES (:x, :y)"),
...         [{"x": 11, "y": 12}, {"x": 13, "y": 14}],
...     )
...     conn.commit()


BEGIN (implicit)
INSERT INTO some_table (x, y) VALUES (?, ?)
[...] [(11, 12), (13, 14)]
<sqlalchemy.engine.cursor.CursorResult object at 0x...>
COMMIT

```

Выполнение операции с помощью метода “executemany” эквивалентно выполнению данного оператора INSERT один раз для каждого
набора параметров, за исключением того, что операция будет оптимизирована для лучшей производительности при работе с
множеством строк.

Одно из ключевых отличий между методами “execute” и “executemany” заключается в том, что последний не поддерживает
возврат результирующих строк, даже если оператор содержит оператор RETURNING. Единственным исключением является
использование конструкции Core insert(), которая будет рассмотрена позднее в этом руководстве, в разделе Использование
операторов INSERT. В этом случае SQLAlchemy использует специальную логику для переорганизации оператора INSERT таким
образом, чтобы он мог выполняться для многих строк, сохраняя при этом возможность использовать оператор RETURNING.

???+ info "См. также"

    executemany - в глоссарии описывается метод курсора DBAPI cursor.executemany(), который используется для большинства
    “executemany” выполнений.
    
    “Поведение при вставке множества значений” для операторов INSERT - в разделе Работа с движками и соединениями
    описывается специальная логика, используемая Insert.returning() для возвращения результирующих наборов при выполнении
    “executemany” операций.

### Выполнение с помощью ORM-сессии {#executing-with-an-orm-session}

Как упоминалось ранее, большинство паттернов и примеров выше применимы и для использования ORM, поэтому здесь мы
представим такое использование, чтобы в дальнейшем можно было иллюстрировать каждый паттерн в терминах использования
Core и ORM вместе.

Основным объектом транзакционного/интерактивного взаимодействия с базой данных при использовании ORM является сессия (
Session). В современном SQLAlchemy этот объект используется очень похожим образом, как Connection, и на самом деле при
использовании Session она внутренне ссылается на Connection, который она использует для генерации SQL-запросов.

Когда Session используется с не-ORM конструкциями, он проходит через SQL-запросы, которые мы ему передаем, и в целом не
делает ничего по-другому, кроме того, что Connection делает непосредственно, поэтому здесь мы можем проиллюстрировать
его использование на простых текстовых SQL-операциях, которые мы уже изучили.

У Session есть несколько разных паттернов создания, но здесь мы продемонстрируем самый простой из них, который точно
соответствует тому, как используется Connection, а именно создание сессии в контекстном менеджере:

``` python
>>> from sqlalchemy.orm import Session
>>> stmt = text("SELECT x, y FROM some_table WHERE y > :y ORDER BY x, y")
>>> with Session(engine) as session:
...     result = session.execute(stmt, {"y": 6})
...     for row in result:
...         print(f"x: {row.x}  y: {row.y}")

BEGIN (implicit)
SELECT x, y FROM some_table WHERE y > ? ORDER BY x, y
[...] (6,)

x: 6  y: 8
x: 9  y: 10
x: 11  y: 12
x: 13  y: 14

ROLLBACK

```

Приведенный выше пример можно сравнить с примером из предыдущего раздела в "Отправке параметров" - мы прямо заменяем
вызов with engine.connect() as conn на with Session(engine) as session, а затем используем метод Session.execute() так
же, как мы это делаем с методом Connection.execute().

Также, как и Connection, Session поддерживает "commit as you go" поведение с использованием метода Session.commit(),
продемонстрированного ниже с помощью текстового оператора UPDATE для изменения некоторых наших данных.

``` python
with Session(engine) as session:
    result = session.execute(
        text("UPDATE some_table SET y=:y WHERE x=:x"),
        [{"x": 9, "y": 11}, {"x": 13, "y": 15}],
    )
    session.commit()
    
# SQL
BEGIN (implicit)
UPDATE some_table SET y=? WHERE x=?
[...] [(11, 9), (15, 13)]
COMMIT

```

Выше мы вызвали оператор UPDATE, используя привязанный параметр и стиль выполнения "executemany", который был введен в
разделе [Отправка нескольких параметров](#sending-multiple-parameters). Блок завершается "commit as you go" коммитом.

!!! tip

    Сессия (Session) фактически не удерживает объект Connection после окончания транзакции. Она получает новый объект
    Connection из Engine в следующий раз, когда ей нужно выполнить SQL-запрос в базе данных.

Однако у Session есть гораздо больше возможностей, и понимание того, что у нее есть метод Session.execute(), который
используется так же, как и метод Connection.execute(), поможет нам начать работу со следующими примерами.

???+ note "См. также"

    Basics of Using a Session - представляет основные шаблоны создания и использования объекта Session.