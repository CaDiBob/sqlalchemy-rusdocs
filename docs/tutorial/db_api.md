title: Работа с транзакциями и DBAPI

## Работа с транзакциями и DBAPI

С Engine готовым к использованию, мы можем приступить к изучению основных операций с Engine и его основных интерактивных
точек, Connection и Result. Кроме того, мы введем фасад ORM для этих объектов, известный как Session.

???+ info "Примечание для читателей ORM"

    При использовании ORM Engine управляется другим объектом, называемым Session. Session в современном SQLAlchemy
    подчеркивает транзакционную и SQL-экспертную модель, которая в основном идентична обсуждаемой ниже Connection, поэтому,
    хотя этот подраздел сосредоточен на Core, все эти концепции существенно важны для ORM-пользователей и рекомендуются для
    всех изучающих ORM. Образец использования Connection будет сопоставлен с Session в конце этого раздела.

Поскольку мы еще не вводили Expression Language SQLAlchemy, который является основной особенностью SQLAlchemy, мы будем
использовать одну простую конструкцию внутри этого пакета, называемую text(), которая позволяет нам записывать
SQL-запросы в виде текстового SQL. Не стоит беспокоиться о том, что текстовый SQL в повседневном использовании
SQLAlchemy является скорее исключением, а не правилом для большинства задач, хотя он всегда остается полностью
доступным.

---

### Получение соединения {#getting-a-connection}

Единственная цель объекта Engine с точки зрения пользователя - предоставить единицу подключения к базе данных,
называемую Connection. При работе с Core напрямую, объект Connection является единственным способом взаимодействия с
базой данных. Так как Connection представляет открытый ресурс для доступа к базе данных, мы всегда должны ограничивать
область его использования конкретным контекстом, а лучший способ сделать это - использовать форму менеджера контекста
Python, также известную как оператор with. Ниже мы иллюстрируем "Hello World", используя текстовый SQL-запрос. Текстовый
SQL генерируется с помощью конструкции text(), о которой будет более подробно рассказано позже:

``` python

from sqlalchemy import text

with engine.connect() as conn:
    result = conn.execute(text("select 'hello world'"))
    print(result.all())

# сгенерированный SQL
BEGIN(implicit)
select
'hello world'
[...]()

# распечатанный result полученный в ходе execute (Python)
[('hello world',)]

# SQL откат транзакции
ROLLBACK

```

В приведенном выше примере, менеджер контекста предоставил подключение к базе данных и также ограничил операцию в рамках
транзакции. По умолчанию поведение Python DBAPI включает то, что транзакция всегда находится в процессе; когда область
действия соединения освобождается, выполняется операция ROLLBACK для завершения транзакции. Транзакция не фиксируется
автоматически; когда мы хотим зафиксировать данные, мы обычно должны вызывать Connection.commit(), как мы увидим в
следующем разделе.

!!! tip "Совет"

    "Автовыполнение" режима доступен для специальных случаев. Раздел "Установка уровней изоляции транзакции", включая "DBAPI
    Autocommit", описывает это.

Результат нашего SELECT также был возвращен в объекте Result, который будет обсуждаться позже, однако на данный момент
стоит отметить, что лучше всего убедиться, что этот объект используется внутри блока "connect" и не передается за его
пределы.

---

### Фиксируем изменения {#committing-changes}

Мы только что узнали, что соединение с БД через DBAPI не имеет автофиксации. Что, если мы хотим зафиксировать
некоторые данные? Мы можем изменить наш предыдущий пример, создав таблицу и добавив некоторые данные. Транзакция затем
фиксируется с помощью метода Connection.commit(), вызванного внутри блока, где мы получили объект Connection:

``` python
# "commit as you go"

>>> with engine.connect() as conn:
...     conn.execute(text("CREATE TABLE some_table (x int, y int)"))
...     conn.execute(
...     text("INSERT INTO some_table (x, y) VALUES (:x, :y)"),
...             [{"x": 1, "y": 1}, {"x": 2, "y": 4}],
...         )
...     conn.commit()

# выполненный SQL
BEGIN (implicit)
CREATE TABLE some_table (x int, y int)
[...] ()
<sqlalchemy.engine.cursor.CursorResult object at 0x...>
INSERT INTO some_table (x, y) VALUES (?, ?)
[...] [(1, 1), (2, 4)]
<sqlalchemy.engine.cursor.CursorResult object at 0x...>
COMMIT
```

В приведенном выше примере мы выполняем два SQL-запроса, которые, как правило, являются транзакционными: запрос на "
CREATE TABLE" [[1](#mark-1)] и запрос на "INSERT", параметризованный (синтаксис параметризации выше будет рассмотрен
ниже в
разделе "Отправка нескольких параметров"). Так как мы хотим, чтобы наша работа была зафиксирована в рамках блока, мы
вызываем метод Connection.commit(), который фиксирует транзакцию. После того как мы вызвали этот метод внутри блока, мы
можем продолжить выполнять SQL-запросы и, если хотим, можем вызвать Connection.commit() еще раз для последующих
запросов. SQLAlchemy называет этот стиль "фиксирование изменений по мере выполнения".

Есть еще один способ фиксации данных, который заключается в том, что мы можем заранее объявить наш блок "connect" как
блок транзакции. Для этого режима работы мы используем метод Engine.begin() для получения соединения вместо метода
Engine.connect(). Этот метод будет управлять областью действия Connection и также заключит все внутри транзакции с
COMMIT в конце, в случае успешного выполнения блока, или ROLLBACK в случае возникновения исключения. Этот стиль может
быть назван "begin once":

``` python

# "begin once"
>>> with engine.begin() as conn:
...     conn.execute(
...         text("INSERT INTO some_table (x, y) VALUES (:x, :y)"),
...         [{"x": 6, "y": 8}, {"x": 9, "y": 10}],
...     )

# SQL
BEGIN (implicit)
INSERT INTO some_table (x, y) VALUES (?, ?)
[...] [(6, 8), (9, 10)]
<sqlalchemy.engine.cursor.CursorResult object at 0x...>
COMMIT

```

Стиль "begin once" часто предпочитается, так как он более лаконичен и позволяет заранее указать намерение всего
блока. Однако в этом руководстве мы обычно будем использовать стиль "фиксировать по мере выполнения", так как он более
гибкий для демонстрационных целей.

!!! info "Что такое "BEGIN (implicit)"?"

    Вы могли заметить строку журнала "BEGIN (implicit)" в начале блока транзакции. "implicit" здесь означает, что SQLAlchemy
    на самом деле не отправляет никакую команду в базу данных; он просто считает это началом неявной транзакции DBAPI. Вы
    можете зарегистрировать события для перехвата этого события, например. 

#### примечание [1] {#mark-1}

DDL относится к подмножеству SQL, которое указывает базе данных создавать, изменять или удалять конструкции на уровне
схемы, такие как таблицы. Рекомендуется помещать DDL, такой, как "CREATE TABLE", в блок транзакции, который
заканчивается
COMMIT, так как многие базы данных используют транзакционный DDL, при котором изменения схемы не происходят до тех пор,
пока транзакция не будет зафиксирована. Однако, как мы увидим позже, обычно мы позволяем SQLAlchemy запускать
последовательности DDL для нас как часть операции более высокого уровня, где нам обычно не нужно беспокоиться о COMMIT.

--- 

### Основы выполнения утверждений(statements)

Мы рассмотрели несколько примеров выполнения операторов SQL в базе данных, используя метод Connection.execute()
совместно с объектом text() и возвращающимся объектом Result. В этом разделе мы более подробно проиллюстрируем механику
и взаимодействие этих компонентов.

???+ info "Об разделе"

    Большая часть содержимого этого раздела одинаково хорошо применима и к современному использованию ORM, при использовании
    метода Session.execute(), который работает очень похоже на Connection.execute(), включая то, что строки результатов ORM
    доставляются с использованием того же интерфейса Result, что и в Core.

#### Извлечение строк

Сначала мы более детально рассмотрим объект Result, используя строки, которые мы ранее вставляли, выполняя текстовый
оператор SELECT на созданной нами таблице:

``` python
>>> with engine.connect() as conn:
...     result = conn.execute(text("SELECT x, y FROM some_table"))
...     for row in result:
...         print(f"x: {row.x} y: {row.y}")

# SQL
BEGIN (implicit)
SELECT x, y FROM some_table
[...] ()

# Python output
x: 1 y: 1
x: 2 y: 4
x: 6 y: 8
x: 9 y: 10

ROLLBACK
```

В приведенном выше примере строка "SELECT" выбрала все строки из нашей таблицы. Возвращаемый объект называется Result и
представляет итерируемый объект строк результатов.

У Result есть много методов для извлечения и преобразования строк, таких как метод Result.all (), показанный ранее,
который возвращает список всех объектов Row. Он также реализует интерфейс Python итератора, чтобы мы могли прямо
перебирать коллекцию объектов Row.

Сами объекты Row реализованы как именованные кортежи Python. Ниже мы иллюстрируем различные способы доступа к
строкам.

- **Распаковка кортежей** - Это наиболее Python-идиоматичный стиль, который заключается в присваивании переменных каждой
  позиции строки при ее получении:

    ``` python
    result = conn.execute(text("select x, y from some_table"))
    
    for x, y in result:
    ...
    ```

- **По индексу** - Кортежи являются последовательностями Python, так что доступ по обычному целочисленному индексу
  также доступен:

    ``` python
    result = conn.execute(text("select x, y from some_table"))
    
    for row in result:
        x = row[0]
    ```

- **По имени атрибута** - Поскольку это именованные кортежи Python, кортежи имеют динамические имена атрибутов,
  соответствующие
  именам каждого столбца. Эти имена обычно соответствуют именам, которые оператор SQL присваивает столбцам в каждой
  строке. Хотя они обычно достаточно предсказуемы и могут также управляться метками, в менее определенных случаях они
  могут подвергаться воздействию специфичных для базы данных поведений:

    ``` python
    result = conn.execute(text("select x, y from some_table"))
    
    for row in result:
        y = row.y
    
        # illustrate use with Python f-strings
        print(f"Row: {row.x} {y}")
    ```

    - **По словарю** - Для получения строк в виде объектов отображения Python, которые являются существенно только для
      чтения версией
      интерфейса Python для общего объекта dict, Result может быть преобразован в объект MappingResult с помощью
      модификатора
      Result.mappings(); это объект результата, который возвращает объекты RowMapping, похожие на словари, вместо
      объектов
      Row:

      ``` python
      result = conn.execute(text("select x, y from some_table"))
    
      for dict_row in result.mappings():
          x = dict_row["x"]
          y = dict_row["y"]
        
      ```

#### Передача параметров

SQL-запросы обычно сопровождаются данными, которые необходимо передать вместе с запросом, как мы видели в примере с
INSERT ранее. Метод Connection.execute() также принимает параметры, которые называются связанными параметрами. Примером
может быть запрос SELECT, который ограничивает количество строк, удовлетворяющих определенным условиям, таким как
строки, где значение поля "y" больше определенного значения, которое передается в функцию.

Чтобы этого достичь и при этом запрос SQL мог оставаться неизменным, а драйвер мог правильно обработать значение, мы
добавляем в WHERE-критерий запроса параметр с именем "y"; для этого мы используем конструкцию text(), в которую
добавляем "y" в формате с двоеточием " :y". Фактическое значение для ":y" передается вторым аргументом в
Connection.execute() в виде словаря:

``` python
>>> with engine.connect() as conn:
...     result = conn.execute(text("SELECT x, y FROM some_table WHERE y > :y"), {"y": 2})
...     for row in result:
...         print(f"x: {row.x}  y: {row.y}")

BEGIN (implicit)
SELECT x, y FROM some_table WHERE y > ?
[...] (2,)

x: 2  y: 4
x: 6  y: 8
x: 9  y: 10

ROLLBACK

```